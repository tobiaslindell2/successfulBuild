from __future__ import annotations

import itertools
import os
import sys
from collections.abc import Iterator
from importlib.machinery import EXTENSION_SUFFIXES
from importlib.util import cache_from_source as _compiled_file_name
from pathlib import Path
from typing import TYPE_CHECKING

from setuptools.dist import Distribution
from setuptools.errors import BaseError
from setuptools.extension import Extension, Library

from distutils import log
from distutils.ccompiler import new_compiler
from distutils.sysconfig import customize_compiler, get_config_var


print(f"CC LOG build_ext.py")
compiler = new_compiler()

print(f"CC LOG compiler 999: {compiler}") # <distutils.unixccompiler.UnixCCompiler object at 0x105d67a90>

import subprocess
def log_ld_lld_location():
    try:
        result = subprocess.run(
            ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/ld.lld", "--version"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        print(f"CC LOG ndk ld.lld Version: {result.stdout.strip()}")
    except Exception as e:
        print(f"CC LOG ld.lld check failed: {e}")

#print("")
#print("")
#env = os.environ.copy()
#print(f"CC LOG env: {env}")
#print("")
#print("")

print(f"CC LOG TYPE_CHECKING: {TYPE_CHECKING}")

if TYPE_CHECKING:
    # Cython not installed on CI tests, causing _build_ext to be `Any`
    from distutils.command.build_ext import build_ext as _build_ext
    print(f"CC LOG _build_ext 1: {_build_ext}")
else:
    try:
        # Attempt to use Cython for building extensions, if available
        from Cython.Distutils.build_ext import build_ext as _build_ext
        print(f"CC LOG _build_ext 2: {_build_ext}")
        
        # Additionally, assert that the compiler module will load
        # also. Ref #1229.
        __import__('Cython.Compiler.Main')
    except ImportError:
        from distutils.command.build_ext import build_ext as _build_ext
        print(f"CC LOG _build_ext 3: {_build_ext}") # <class 'distutils.command.build_ext.build_ext'>

# make sure _config_vars is initialized
get_config_var("LDSHARED")

testingTesting = get_config_var("LDSHARED")
print(f"CC LOG get_config_var: {testingTesting}")

# Not publicly exposed in typeshed distutils stubs, but this is done on purpose
# See https://github.com/pypa/setuptools/pull/4228#issuecomment-1959856400
from distutils.sysconfig import _config_vars as _CONFIG_VARS  # noqa: E402
#print(f"CC LOG _CONFIG_VARS 1: {_CONFIG_VARS}")

def _customize_compiler_for_shlib(compiler): # KOMMER ALRIG HIT
    print(f"CC LOG sys.platform 1: Ë†{sys.platform}")
    if sys.platform == "darwin":
        # building .dylib requires additional compiler flags on OSX; here we
        # temporarily substitute the pyconfig.h variables so that distutils'
        # 'customize_compiler' uses them before we build the shared libraries.
        tmp = _CONFIG_VARS.copy()
        print(f"CC LOG tmp = tmp")
        try:
            #print(f"CC LOG tmp: {tmp}")
            # XXX Help!  I don't have any idea whether these are right...
            _CONFIG_VARS['LDSHARED'] = (
                "gcc -Wl,-x -dynamiclib -undefined dynamic_lookup"
            )
            _CONFIG_VARS['CCSHARED'] = " -dynamiclib"
            _CONFIG_VARS['SO'] = ".dylib"
            customize_compiler(compiler)
            print(f"CC LOG _CONFIG_VARS 2: {_CONFIG_VARS}")
        finally:
            _CONFIG_VARS.clear()
            _CONFIG_VARS.update(tmp)
            print(f"CC LOG _CONFIG_VARS 3: {_CONFIG_VARS}")
        
        
    else:
        customize_compiler(compiler)

#_CONFIG_VARS = env
#print("")
#print(f"CC LOG _CONFIG_VARS 2: {_CONFIG_VARS}")
#print("")



have_rtld = False
use_stubs = False
libtype = 'shared'

print(f"CC LOG sys.platform 2: {sys.platform}") # darwin
if sys.platform == "darwin":
    use_stubs = True
elif os.name != 'nt':
    try:
        import dl  # type: ignore[import-not-found] # https://github.com/python/mypy/issues/13002

        use_stubs = have_rtld = hasattr(dl, 'RTLD_NOW')
    except ImportError:
        pass


def if_dl(s):
    return s if have_rtld else ''


def get_abi3_suffix():
    """Return the file extension for an abi3-compliant Extension()"""
    for suffix in EXTENSION_SUFFIXES:
        if '.abi3' in suffix:  # Unix
            print(f"CC LOG suffix 1: {suffix}") # .abi3.so
            return suffix
        elif suffix == '.pyd':  # Windows
            print(f"CC LOG suffix 2: {suffix}")
            return suffix
    return None


class build_ext(_build_ext):
    distribution: Distribution  # override distutils.dist.Distribution with setuptools.dist.Distribution
    editable_mode = False
    inplace = False
    
    print(f"CC LOG build_ext(_build_ext)")
    
    def run(self):
        """Build extensions in build directory, then copy if --inplace"""
        print(f"CC LOG self.inplace: {self.inplace}") # False
        print(f"CC LOG self 22: {self}") # <setuptools_rust.setuptools_ext.add_rust_extension.<locals>.build_ext_rust_extension object at 0x105a177d0>
        print(f"CC LOG Attributes of self: {dir(self)}")
        
        print("")
        print("ROUND QUATRO")
        print(f"CC LOG self:                        {self}")
        print(f"CC LOG vars(self) 1:                {vars(self)}")
        old_inplace, self.inplace = self.inplace, False
        #print(f"CC LOG old_inplace 1: {old_inplace}") # False
        #print(f"CC LOG _build_ext.run(self): {_build_ext.run(self)}")
        
        
        #self.build_lib = "build/lib.macosx-14.4-arm64-cpython-311"
        self.plat_name = "linux-aarch64"
        #self.build_temp = "build/temp.linux-aarch64-cpython-311"
        self.include_dirs = ["/Users/tobiaslindell/Downloads/localStuff/python3/Include", "/Users/tobiaslindell/Downloads/localStuff/python3"]
        print("")
        print("CC LOG _CONFIG_VARS FULL:")
        for key, value in _CONFIG_VARS.items():
        	print(f"{key}: {value}")
        print("")
        compiler.compiler = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang" , "-target", "aarch64-linux-android33"]
        compiler.compiler_so = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang", "-shared"]
        compiler.compiler_cxx = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang++"]
        compiler.linker_so = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang" , "-shared", "-fuse-ld=lld"]
        compiler.archiver = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/llvm-ar" , "-cr"]
        compiler.ranlib = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/llvm-ranlib" , "-cr"]
        
        compiler.executables["compiler"] = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang", "--sysroot", "/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot", "-fPIC", "-march=armv8-a", "-pthread"]
        compiler.executables["compiler_so"] = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang", "--sysroot", "/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot", "-shared", "-fPIC", "-march=armv8-a", "-pthread"]
        compiler.executables["compiler_cxx"] = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang++", "--sysroot", "/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot", "-std=c++17", "-fPIC", "-march=armv8-a", "-pthread"]
        compiler.executables["compiler_so_cxx"] = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang++", "--sysroot", "/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot", "-shared", "-std=c++17", "-fPIC", "-march=armv8-a", "-pthread"]
        compiler.executables["linker_so"] = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang", "--sysroot", "/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot", "-shared", "-fuse-ld=lld", "-pthread"]
        compiler.executables["linker_so_cxx"] = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang++", "--sysroot", "/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot", "-shared", "-fuse-ld=lld", "-pthread"]
        compiler.executables["archiver"] = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/llvm-ar" , "-cr"]
        compiler.executables["ranlib"] = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/llvm-ranlib"]
        compiler.executables["linker_exe"] = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang", "--sysroot", "/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot", "-fuse-ld=lld", "-pthread"]
        compiler.executables["linker_exe_cxx"] = ["/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android33-clang++", "--sysroot", "/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot", "-std=c++17", "-fuse-ld=lld", "-pthread"]
        
        openssl_lib_path = "/Users/tobiaslindell/Downloads/localStuff/openssl1.1"
        compiler.executables["linker_so"] += [f"-L{openssl_lib_path}"]
        compiler.executables["linker_so_cxx"] += [f"-L{openssl_lib_path}"]
        compiler.executables["linker_exe"] += [f"-L{openssl_lib_path}"]
        compiler.executables["linker_exe_cxx"] += [f"-L{openssl_lib_path}"]
        
        for var in ('CFLAGS', 'LDFLAGS', 'CXXFLAGS'):
        	if var in os.environ:
        		del os.environ[var]
        
        #_CONFIG_VARS['CC'] = compiler.executables["compiler"][0]
        #_CONFIG_VARS['CXX'] = compiler.executables["compiler_cxx"][0]
        print(f"CC LOG NEW _CONFIG_VARS['LD_LIBRARY_PATH'] 1: {_CONFIG_VARS['LD_LIBRARY_PATH']}")
        _CONFIG_VARS['CC'] = " ".join(compiler.executables["compiler"])
        _CONFIG_VARS['CXX'] = " ".join(compiler.executables["compiler_cxx"])
        _CONFIG_VARS['LDSHARED'] = " ".join(compiler.executables["linker_so"])
        _CONFIG_VARS['LDCXXSHARED'] = " ".join(compiler.executables["linker_so_cxx"])
        _CONFIG_VARS['LD_LIBRARY_PATH'] = "/Users/tobiaslindell/appStuff/.buildozer/android/platform/build-arm64-v8a/dists/convokeeper/libs/arm64-v8a"
        #_CONFIG_VARS['AR'] = compiler.executables["archiver"][0]
        #_CONFIG_VARS['RANLIB'] = compiler.executables["ranlib"][0]
        _CONFIG_VARS['AR'] = " ".join(compiler.executables["archiver"])
        _CONFIG_VARS['RANLIB'] = " ".join(compiler.executables["ranlib"])
        _CONFIG_VARS['LIBDIR'] = openssl_lib_path
        _CONFIG_VARS['LIBPL'] = openssl_lib_path
        _CONFIG_VARS['LDFLAGS'] = ""
        _CONFIG_VARS['LDFLAGS'] = f"-L{openssl_lib_path} -L/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/lib/aarch64-linux-android"
        _CONFIG_VARS['LIBS'] = ""
        _CONFIG_VARS['LIBS'] = "-ldl -lc -lm"
        _CONFIG_VARS['CFLAGS'] = ("--sysroot " + "/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot" + " -fPIC -march=armv8-a -DANDROID")
        _CONFIG_VARS['CXXFLAGS'] = ("--sysroot " + "/Users/tobiaslindell/Library/Android/sdk/ndk/25.1.8937393//toolchains/llvm/prebuilt/darwin-x86_64/sysroot" + " -fPIC -march=armv8-a -std=c++17 -DANDROID")
        print(f"CC LOG NEW _CONFIG_VARS['LD_LIBRARY_PATH'] 2: {_CONFIG_VARS['LD_LIBRARY_PATH']}")
        
        os.environ.pop('LDFLAGS', None)
        os.environ.pop('LIBS', None)
        os.environ['CFLAGS'] = _CONFIG_VARS['CFLAGS']
        os.environ['CXXFLAGS'] = _CONFIG_VARS['CXXFLAGS']
        os.environ['LDFLAGS'] = _CONFIG_VARS['LDFLAGS']
        
        # Remove problematic flags from LDSHARED
        if 'LDSHARED' in _CONFIG_VARS and ('-bundle' in _CONFIG_VARS['LDSHARED'] or '-undefined' in _CONFIG_VARS['LDSHARED']):
        	_CONFIG_VARS['LDSHARED'] = _CONFIG_VARS['LDSHARED'].replace('-bundle', '').replace('-undefined', '').replace('-lpthread', '')
        	
        # Strip -lpthread from all CONFIG_VARS
        for key in ('LDFLAGS', 'LIBS', 'CFLAGS', 'CXXFLAGS', 'LDSHARED', 'LDCXXSHARED'):
        	if key in _CONFIG_VARS:
        		_CONFIG_VARS[key] = _CONFIG_VARS[key].replace("-lpthread", "")
        
        # Strip -lpthread from all environment variables
        for env_var in ('LDFLAGS', 'LIBS', 'CFLAGS', 'CXXFLAGS'):
        	if env_var in os.environ:
        		os.environ[env_var] = os.environ[env_var].replace("-lpthread", "")
        
        for flag_group in ('compiler', 'compiler_so', 'compiler_cxx', 'compiler_so_cxx',
                           'linker_so', 'linker_so_cxx', 'linker_exe', 'linker_exe_cxx'):
            compiler.executables[flag_group] = [
            	flag for flag in compiler.executables[flag_group] if flag != "-lpthread"
            ]
        
        print("")
        print(f"CC LOG vars(self) 2:                {vars(self)}")
        print(f"CC LOG new_compiler:                {new_compiler}") # <function new_compiler at 0x104171c60>
        print(f"CC LOG compiler:                    {compiler}")
        print(f"CC LOG compiler.compiler:           {compiler.compiler}")
        print(f"CC LOG type(compiler):              {type(compiler)}")
        print(f"CC LOG compiler.executables:        {compiler.executables}")
        #print(f"CC LOG _CONFIG_VARS:                {_CONFIG_VARS}")
        print(f"CC LOG _CONFIG_VARS['CC']:          {_CONFIG_VARS['CC']}")
        print(f"CC LOG _CONFIG_VARS['CXX']:         {_CONFIG_VARS['CXX']}")
        print(f"CC LOG _CONFIG_VARS['LDSHARED']:    {_CONFIG_VARS['LDSHARED']}")
        print(f"CC LOG _CONFIG_VARS['LDCXXSHARED']: {_CONFIG_VARS['LDCXXSHARED']}")
        print(f"CC LOG _CONFIG_VARS['AR']:          {_CONFIG_VARS['AR']}")
        print(f"CC LOG _CONFIG_VARS['RANLIB']:      {_CONFIG_VARS['RANLIB']}")
        print(f"CC LOG _CONFIG_VARS['LIBDIR']:      {_CONFIG_VARS['LIBDIR']}")
        print(f"CC LOG _CONFIG_VARS['LIBPL']:       {_CONFIG_VARS['LIBPL']}")
        print(f"CC LOG _CONFIG_VARS['LDFLAGS']:     {_CONFIG_VARS['LDFLAGS']}")
        print(f"CC LOG _CONFIG_VARS['LIBS']:        {_CONFIG_VARS['LIBS']}")
        print(f"CC LOG _CONFIG_VARS['CFLAGS']:      {_CONFIG_VARS['CFLAGS']}")
        print(f"CC LOG _CONFIG_VARS['CXXFLAGS']:    {_CONFIG_VARS['CXXFLAGS']}")
        ld_ldd = log_ld_lld_location()
        
        #for ext in self.extensions:
        #	print(f"CC LOG Extension '{ext.name}' extra_link_args: {getattr(ext, 'extra_link_args', None)}")
        
        #print(f"CC LOG compiler.linker_so:                       {compiler.linker_so}")
        #print(f"CC LOG compiler.include_dirs:                    {compiler.include_dirs}")
        #print(f"CC LOG compiler.library_dirs:                    {compiler.library_dirs}")
        #print(f"CC LOG getattr(compiler, 'macros', 'No macros'): {getattr(compiler, 'macros', 'No macros')}")
        #print(f"CC LOG compiler.compiler_so:                     {compiler.compiler_so}")
        #print(f"CC LOG compiler.compiler_cxx:                    {compiler.compiler_cxx}")
        #print(f"CC LOG compiler.linker_so:                       {compiler.linker_so}")
        print("")
        print("")
        
        _build_ext.run(self)
        self.inplace = old_inplace
        print(f"CC LOG old_inplace 2: {old_inplace}")
        if old_inplace:
            self.copy_extensions_to_source()

    def _get_inplace_equivalent(self, build_py, ext: Extension) -> tuple[str, str]: # KOMMER ALRIG HIT
        fullname = self.get_ext_fullname(ext.name)
        print(f"CC LOG fullname: {fullname}")
        filename = self.get_ext_filename(fullname)
        print(f"CC LOG filename: {filename}")
        modpath = fullname.split('.')
        print(f"CC LOG modpath: {modpath}")
        package = '.'.join(modpath[:-1])
        print(f"CC LOG package: {package}")
        package_dir = build_py.get_package_dir(package)
        print(f"CC LOG package_dir: {package_dir}")
        inplace_file = os.path.join(package_dir, os.path.basename(filename))
        print(f"CC LOG inplace_file: {inplace_file}")
        regular_file = os.path.join(self.build_lib, filename)
        print(f"CC LOG regular_file: {regular_file}")
        return (inplace_file, regular_file)

    def copy_extensions_to_source(self) -> None: # KOMMER ALDRIG HIT
        build_py = self.get_finalized_command('build_py')
        print(f"CC LOG build_py: {build_py}")
        for ext in self.extensions:
            inplace_file, regular_file = self._get_inplace_equivalent(build_py, ext)

            # Always copy, even if source is older than destination, to ensure
            # that the right extensions for the current Python/platform are
            # used.
            if os.path.exists(regular_file) or not ext.optional:
                self.copy_file(regular_file, inplace_file, level=self.verbose)

            if ext._needs_stub:
                inplace_stub = self._get_equivalent_stub(ext, inplace_file)
                self._write_stub_file(inplace_stub, ext, compile=True)
                # Always compile stub and remove the original (leave the cache behind)
                # (this behaviour was observed in previous iterations of the code)

    def _get_equivalent_stub(self, ext: Extension, output_file: str) -> str: # KOMMER ALDRIG HIT
        dir_ = os.path.dirname(output_file)
        print(f"CC LOG dir_: {dir_}")
        _, _, name = ext.name.rpartition(".")
        return f"{os.path.join(dir_, name)}.py"

    def _get_output_mapping(self) -> Iterator[tuple[str, str]]: # KOMMER ALRIG HIT
        print(f"CC LOG self.inplace 2: {self.inplace}")
        if not self.inplace:
            return

        build_py = self.get_finalized_command('build_py')
        opt = self.get_finalized_command('install_lib').optimize or ""

        for ext in self.extensions:
            inplace_file, regular_file = self._get_inplace_equivalent(build_py, ext)
            yield (regular_file, inplace_file)

            if ext._needs_stub:
                # This version of `build_ext` always builds artifacts in another dir,
                # when "inplace=True" is given it just copies them back.
                # This is done in the `copy_extensions_to_source` function, which
                # always compile stub files via `_compile_and_remove_stub`.
                # At the end of the process, a `.pyc` stub file is created without the
                # corresponding `.py`.

                inplace_stub = self._get_equivalent_stub(ext, inplace_file)
                regular_stub = self._get_equivalent_stub(ext, regular_file)
                inplace_cache = _compiled_file_name(inplace_stub, optimization=opt)
                output_cache = _compiled_file_name(regular_stub, optimization=opt)
                yield (output_cache, inplace_cache)

    def get_ext_filename(self, fullname: str) -> str:
        so_ext = os.getenv('SETUPTOOLS_EXT_SUFFIX')
        print(f"CC LOG so_ext 2: {so_ext}") # None
        if so_ext:
            filename = os.path.join(*fullname.split('.')) + so_ext
            print(f"CC LOG filename 2: {filename}")
        else:
            filename = _build_ext.get_ext_filename(self, fullname)
            print(f"CC LOG filename 3: {filename}") # cryptography/hazmat/bindings/_openssl.cpython-311-darwin.so
            ext_suffix = get_config_var('EXT_SUFFIX')
            print(f"CC LOG ext_suffix 2: {ext_suffix}") # .cpython-311-darwin.so
            if not isinstance(ext_suffix, str):
                raise OSError(
                    "Configuration variable EXT_SUFFIX not found for this platform "
                    "and environment variable SETUPTOOLS_EXT_SUFFIX is missing"
                )
            so_ext = ext_suffix

        if fullname in self.ext_map:
            ext = self.ext_map[fullname]
            print(f"CC LOG ext 2: {ext}") # <setuptools.extension.Extension('cryptography.hazmat.bindings._openssl') at 0x105c83ad0>
            abi3_suffix = get_abi3_suffix()
            print(f"CC LOG abi3_suffix 2: {abi3_suffix}") # .abi3.so
            if ext.py_limited_api and abi3_suffix:  # Use abi3
                filename = filename[: -len(so_ext)] + abi3_suffix
                print(f"CC LOG filename 4: {filename}") # cryptography/hazmat/bindings/_openssl.abi3.so
            if isinstance(ext, Library):
                fn, ext = os.path.splitext(filename)
                print(f"CC LOG fn, ext: {os.path.splitext(filename)}")
                return self.shlib_compiler.library_filename(fn, libtype)
            elif use_stubs and ext._links_to_dynamic:
                d, fn = os.path.split(filename)
                print(f"CC LOG d, fn: {os.path.split(filename)}")
                return os.path.join(d, 'dl-' + fn)
        return filename

    def initialize_options(self):
        print(f"CC LOG initialize_options(self)")
        _build_ext.initialize_options(self)
        print(f"CC LOG _build_ext.initialize_options(self): {_build_ext.initialize_options(self)}") # None
        self.shlib_compiler = None
        self.shlibs = []
        self.ext_map = {}
        self.editable_mode = False

    def finalize_options(self) -> None:
        print(f"CC LOG: Entering _build_ext.finalize_options()")
        _build_ext.finalize_options(self)
        print(f"CC LOG: Exited _build_ext.finalize_options()")
        print(f"CC LOG: self.compiler after finalize_options: {self.compiler}") # None
        print(f"CC LOG: self.shlib_compiler after finalize_options: {self.shlib_compiler}") # None
        print(f"CC LOG: self.include_dirs after finalize_options: {self.include_dirs}")
        print(f"CC LOG: self.library_dirs after finalize_options: {self.library_dirs}")
        print(f"CC LOG selfFromCompiler: {self}")
        self.extensions = self.extensions or []
        print(f"CC LOG self.extensions: {self.extensions}") # [<setuptools.extension.Extension('cryptography.hazmat.bindings._openssl') at 0x103e96750>]
        self.check_extensions_list(self.extensions)
        print(f"CC LOG self.check_extensions_list(self.extensions): {self.check_extensions_list(self.extensions)}") # None
        self.shlibs = [ext for ext in self.extensions if isinstance(ext, Library)]
        print(f"CC LOG self.shlibs: {self.shlibs}") # []
        if self.shlibs:
            self.setup_shlib_compiler()
            print(f"CC LOG self.setup_shlib_compiler(): {self.setup_shlib_compiler()}")
        for ext in self.extensions:
            ext._full_name = self.get_ext_fullname(ext.name)
            print(f"CC LOG self.get_ext_fullname(ext.name): {self.get_ext_fullname(ext.name)}") # cryptography.hazmat.bindings._openssl
        for ext in self.extensions:
            fullname = ext._full_name
            print(f"CC LOG fullname: {fullname}") # cryptography.hazmat.bindings._openssl
            self.ext_map[fullname] = ext
            print(f"self.ext_map[fullname]: {self.ext_map[fullname]}") # <setuptools.extension.Extension('cryptography.hazmat.bindings._openssl') at 0x1026cec90>
            
            # distutils 3.1 will also ask for module names
            # XXX what to do with conflicts?
            self.ext_map[fullname.split('.')[-1]] = ext
            print(f"CC LOG ext 3: {ext}") # <setuptools.extension.Extension('cryptography.hazmat.bindings._openssl') at 0x103a92890>
            ltd = self.shlibs and self.links_to_dynamic(ext) or False
            print(f"CC LOG ltd: {ltd}") # False
            ns = ltd and use_stubs and not isinstance(ext, Library)
            ltd = self.shlibs and self.links_to_dynamic(ext) or False
            print(f"CC LOG ltd: {ltd}") # False
            ext._links_to_dynamic = ltd
            ext._needs_stub = ns
            filename = ext._file_name = self.get_ext_filename(fullname)
            print(f"CC LOG filename 4: {filename}") # _openssl.abi3.so
            libdir = os.path.dirname(os.path.join(self.build_lib, filename))
            print(f"CC LOG libdir 1: {libdir}") # build/lib.macosx-14.4-arm64-cpython-311/cryptography/hazmat/bindings
            if ltd and libdir not in ext.library_dirs:
                ext.library_dirs.append(libdir)
                print(f"CC LOG ext.library_dirs: {ext.library_dirs}")
            if ltd and use_stubs and os.curdir not in ext.runtime_library_dirs:
                ext.runtime_library_dirs.append(os.curdir)
                print(f"CC LOG curdir: {curdir}")
                print(f"CC LOG ext.runtime_library_dirs: {ext.runtime_library_dirs}")

        if self.editable_mode:
            self.inplace = True

    def setup_shlib_compiler(self): # KPMMER ALDRIG HIT
        print("CC LOG setup_shlib_compiler")
        compiler = self.shlib_compiler = new_compiler(
            compiler=self.compiler, dry_run=self.dry_run, force=self.force
        )
        print(f"CC LOG compiler 777: {compiler}")
        _customize_compiler_for_shlib(compiler)
        print(f"CC LOG compiler 888: {compiler}")

        if self.include_dirs is not None:
            compiler.set_include_dirs(self.include_dirs)
        if self.define is not None:
            # 'define' option is a list of (name,value) tuples
            for name, value in self.define:
                compiler.define_macro(name, value)
        if self.undef is not None:
            for macro in self.undef:
                compiler.undefine_macro(macro)
        if self.libraries is not None:
            compiler.set_libraries(self.libraries)
        if self.library_dirs is not None:
            compiler.set_library_dirs(self.library_dirs)
        if self.rpath is not None:
            compiler.set_runtime_library_dirs(self.rpath)
        if self.link_objects is not None:
            compiler.set_link_objects(self.link_objects)

        # hack so distutils' build_extension() builds a library instead
        compiler.link_shared_object = link_shared_object.__get__(compiler)  # type: ignore[method-assign]

    def get_export_symbols(self, ext):
        print(f"CC LOG def get_export_symbols(self, ext)")
        if isinstance(ext, Library):
            print(f"CC LOG ext.export_symbols: {ext.export_symbols}")
            return ext.export_symbols
        print(f"CC LOG _build_ext.get_export_symbols(self, ext): {_build_ext.get_export_symbols(self, ext)}") # ['PyInit__openssl']
        return _build_ext.get_export_symbols(self, ext)

    def build_extension(self, ext) -> None:
        ext._convert_pyx_sources_to_lang()
        _compiler = self.compiler
        print(f"CC LOG _compiler 1: {_compiler}") # <distutils.unixccompiler.UnixCCompiler object at 0x10292c8d0>
        try:
            if isinstance(ext, Library):
                self.compiler = self.shlib_compiler
                print(f"	: {self.compiler}") # {self.compiler}")
            _build_ext.build_extension(self, ext)
            print(f"CC LOG _build_ext.build_extension(self, ext): {_build_ext.build_extension(self, ext)}")
            if ext._needs_stub:
                build_lib = self.get_finalized_command('build_py').build_lib
                print(f"CC LOG build_lib: {build_lib}")
                self.write_stub(build_lib, ext)
                print(f"CC LOG self.write_stub(build_lib, ext): {self.write_stub(build_lib, ext)}")
        finally:
            self.compiler = _compiler
            print(f"CC LOG self.compiler 3: {self.compiler}") # <distutils.unixccompiler.UnixCCompiler object at 0x10374e790>

    def links_to_dynamic(self, ext): # KOMMER ALRIG HIT
        """Return true if 'ext' links to a dynamic lib in the same package"""
        print(f"CC LOG def links_to_dynamic")
        # XXX this should check to ensure the lib is actually being built
        # XXX as dynamic, and not just using a locally-found version or a
        # XXX static-compiled version
        libnames = dict.fromkeys([lib._full_name for lib in self.shlibs])
        print(f"CC LOG libnames: {libnames}")
        
        pkg = '.'.join(ext._full_name.split('.')[:-1] + [''])
        return any(pkg + libname in libnames for libname in ext.libraries)

    def get_source_files(self) -> list[str]: # KOMMER ALRIG HIT
        print(f"CC LOG [*_build_ext.get_source_files(self), *self._get_internal_depends()]: {[*_build_ext.get_source_files(self), *self._get_internal_depends()]}")
        return [*_build_ext.get_source_files(self), *self._get_internal_depends()]

    def _get_internal_depends(self) -> Iterator[str]: # KOMMER ALRIG HIT
        """Yield ``ext.depends`` that are contained by the project directory"""
        project_root = Path(self.distribution.src_root or os.curdir).resolve()
        print(f"CC LOG project_root: {project_root}")
        depends = (dep for ext in self.extensions for dep in ext.depends)

        def skip(orig_path: str, reason: str) -> None:
            log.info(
                "dependency %s won't be automatically "
                "included in the manifest: the path %s",
                orig_path,
                reason,
            )

        for dep in depends:
            path = Path(dep)

            if path.is_absolute():
                skip(dep, "must be relative")
                continue

            if ".." in path.parts:
                skip(dep, "can't have `..` segments")
                continue

            try:
                resolved = (project_root / path).resolve(strict=True)
            except OSError:
                skip(dep, "doesn't exist")
                continue

            try:
                resolved.relative_to(project_root)
            except ValueError:
                skip(dep, "must be inside the project root")
                continue

            yield path.as_posix()

    def get_outputs(self) -> list[str]: # KOMMER ALDRIG HIT
        print("CC LOG def get_outputs()")
        if self.inplace:
            return list(self.get_output_mapping().keys())
        return sorted(_build_ext.get_outputs(self) + self.__get_stubs_outputs())

    def get_output_mapping(self) -> dict[str, str]:
        """See :class:`setuptools.commands.build.SubCommand`"""
        print("CC LOG def get_output_mapping()")
        mapping = self._get_output_mapping()
        return dict(sorted(mapping, key=lambda x: x[0]))

    def __get_stubs_outputs(self):
        # assemble the base name for each extension that needs a stub
        print("CC LOG def __get_stubs_outputs()")
        ns_ext_bases = (
            os.path.join(self.build_lib, *ext._full_name.split('.'))
            for ext in self.extensions
            if ext._needs_stub
        )
        # pair each base with the extension
        pairs = itertools.product(ns_ext_bases, self.__get_output_extensions())
        return list(base + fnext for base, fnext in pairs)

    def __get_output_extensions(self):
        print("CC LOG def __get_output_extensions()")
        yield '.py'
        yield '.pyc'
        if self.get_finalized_command('build_py').optimize:
            yield '.pyo'

    def write_stub(self, output_dir, ext, compile=False) -> None:
        print("CC LOG def write_stub()")
        stub_file = os.path.join(output_dir, *ext._full_name.split('.')) + '.py'
        self._write_stub_file(stub_file, ext, compile)

    def _write_stub_file(self, stub_file: str, ext: Extension, compile=False):
        print("CC LOG def _write_stub_file()")
        log.info("writing stub loader for %s to %s", ext._full_name, stub_file)
        if compile and os.path.exists(stub_file):
            raise BaseError(stub_file + " already exists! Please delete.")
        if not self.dry_run:
            with open(stub_file, 'w', encoding="utf-8") as f:
                content = '\n'.join([
                    "def __bootstrap__():",
                    "   global __bootstrap__, __file__, __loader__",
                    "   import sys, os, pkg_resources, importlib.util" + if_dl(", dl"),
                    "   __file__ = pkg_resources.resource_filename"
                    f"(__name__,{os.path.basename(ext._file_name)!r})",
                    "   del __bootstrap__",
                    "   if '__loader__' in globals():",
                    "       del __loader__",
                    if_dl("   old_flags = sys.getdlopenflags()"),
                    "   old_dir = os.getcwd()",
                    "   try:",
                    "     os.chdir(os.path.dirname(__file__))",
                    if_dl("     sys.setdlopenflags(dl.RTLD_NOW)"),
                    "     spec = importlib.util.spec_from_file_location(",
                    "                __name__, __file__)",
                    "     mod = importlib.util.module_from_spec(spec)",
                    "     spec.loader.exec_module(mod)",
                    "   finally:",
                    if_dl("     sys.setdlopenflags(old_flags)"),
                    "     os.chdir(old_dir)",
                    "__bootstrap__()",
                    "",  # terminal \n
                ])
                f.write(content)
        if compile:
            self._compile_and_remove_stub(stub_file)

    def _compile_and_remove_stub(self, stub_file: str):
        print("CC LOG def _compile_and_remove_stub()")
        from distutils.util import byte_compile

        byte_compile([stub_file], optimize=0, force=True, dry_run=self.dry_run)
        optimize = self.get_finalized_command('install_lib').optimize
        if optimize > 0:
            byte_compile(
                [stub_file],
                optimize=optimize,
                force=True,
                dry_run=self.dry_run,
            )
        if os.path.exists(stub_file) and not self.dry_run:
            os.unlink(stub_file)


if use_stubs or os.name == 'nt':
    # Build shared libraries
    #
    print("CC LOG def link_shared_object() 1")
    def link_shared_object(
        self,
        objects,
        output_libname,
        output_dir=None,
        libraries=None,
        library_dirs=None,
        runtime_library_dirs=None,
        export_symbols=None,
        debug: bool = False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ) -> None:
        self.link(
            self.SHARED_LIBRARY,
            objects,
            output_libname,
            output_dir,
            libraries,
            library_dirs,
            runtime_library_dirs,
            export_symbols,
            debug,
            extra_preargs,
            extra_postargs,
            build_temp,
            target_lang,
        )

else:
    # Build static libraries everywhere else
    libtype = 'static'
    
    print("CC LOG def link_shared_object() 2")
    def link_shared_object(
        self,
        objects,
        output_libname,
        output_dir=None,
        libraries=None,
        library_dirs=None,
        runtime_library_dirs=None,
        export_symbols=None,
        debug: bool = False,
        extra_preargs=None,
        extra_postargs=None,
        build_temp=None,
        target_lang=None,
    ) -> None:
        # XXX we need to either disallow these attrs on Library instances,
        # or warn/abort here if set, or something...
        # libraries=None, library_dirs=None, runtime_library_dirs=None,
        # export_symbols=None, extra_preargs=None, extra_postargs=None,
        # build_temp=None

        assert output_dir is None  # distutils build_ext doesn't pass this
        output_dir, filename = os.path.split(output_libname)
        basename, _ext = os.path.splitext(filename)
        if self.library_filename("x").startswith('lib'):
            # strip 'lib' prefix; this is kludgy if some platform uses
            # a different prefix
            basename = basename[3:]

        self.create_static_lib(objects, basename, output_dir, debug, target_lang)
    
#print("")
#print(f"CC LOG _CONFIG_VARS 3: {_CONFIG_VARS}")
#print("")
